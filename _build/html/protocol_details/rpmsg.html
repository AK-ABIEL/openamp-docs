<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RPMsg Messaging Protocol &mdash; OpenAMP  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/mystyle.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="RPMsg Communication Flow" href="rpmsg_comms.html" />
    <link rel="prev" title="Components and Capabilities" href="components.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> OpenAMP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../openamp/index.html">OpenAMP Project</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">OpenAMP Protocol Details</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="asymmetric_mp.html">Asymmetric Multiprocessing Intro</a></li>
<li class="toctree-l2"><a class="reference internal" href="components.html">Components and Capabilities</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">RPMsg Messaging Protocol</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#protocol-layers">Protocol Layers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#physical-layer-shared-memory">Physical Layer – Shared Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#media-access-layer-virtio">Media Access Layer - VirtIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transport-layer-rpmsg">Transport Layer - RPMsg</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rpmsg-protocol-limitations">RPMsg Protocol Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="rpmsg_comms.html">RPMsg Communication Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="lifecyclemgmt.html">Life Cycle Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="system_considerations.html">System Wide Considerations</a></li>
<li class="toctree-l2"><a class="reference internal" href="porting_guide.html">Porting GuideLine</a></li>
<li class="toctree-l2"><a class="reference internal" href="resource_tbl.html">Resource Table Evolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="openamp_ci.html">Using OpenAMP CI</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../docs/index.html">OpenAMP API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OpenAMP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">OpenAMP Protocol Details</a> &raquo;</li>
      <li>RPMsg Messaging Protocol</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/protocol_details/rpmsg.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="rpmsg-messaging-protocol">
<span id="rpmsg-protocol-work-label"></span><h1>RPMsg Messaging Protocol<a class="headerlink" href="#rpmsg-messaging-protocol" title="Permalink to this heading"></a></h1>
<p>In asymmetric multiprocessor systems, the most common way for different cores to cooperate is to use a shared memory-based communication. There are many custom implementations, which means that the considered systems cannot be directly interconnected. Therefore, this document’s aim is to offer a standardization of this communication based on existing components (RPMsg, VirtIO).</p>
<section id="protocol-layers">
<h2>Protocol Layers<a class="headerlink" href="#protocol-layers" title="Permalink to this heading"></a></h2>
<p>The whole communication implementation can be separated in three different ISO/OSI layers - Transport, Media Access Control and Physical layer. Each of them can be implemented separately and for example multiple implementations of the Transport Layer can share the same implementation of the MAC Layer (VirtIO) and the Physical Layer. Each layer is described in following sections.</p>
<img alt="../_images/protocol_layers.jpg" src="../_images/protocol_layers.jpg" />
<section id="physical-layer-shared-memory">
<h3>Physical Layer – Shared Memory<a class="headerlink" href="#physical-layer-shared-memory" title="Permalink to this heading"></a></h3>
<p>The solution proposed in this document requires only two basic hardware components - shared memory (accessible by both communicating sides) and inter-core interrupts (in a specific configuration optional). The minimum configuration requires one interrupt line per communicating core meaning two interrupts in total. This configuration is briefly presented in figure at the beginning of this section. It is to be noticed that no inter-core synchronization hardware element such as inter-core semaphore, inter-core queue or inter-core mutex is needed! This is thanks to the nature of the virtqueue, which uses single-writer-single-reader circular buffering. (As defined in next subsection)</p>
<p>In case the “used” and “avail” ring buffers have a bit set in their configuration flags field, the generation of interrupts can be completely suppressed - in such a configuration, the interrupts are not necessary. However both cores need to poll the “ring” and “used” ring buffers for new incoming messages, which may not be optimal.</p>
<img alt="../_images/core_to_core_interrupt.jpg" src="../_images/core_to_core_interrupt.jpg" />
</section>
<section id="media-access-layer-virtio">
<h3>Media Access Layer - VirtIO<a class="headerlink" href="#media-access-layer-virtio" title="Permalink to this heading"></a></h3>
<p>This layer is the key part of the whole solution - thanks to this layer, there is no need for inter-core synchronization. This is achieved by a technique called single-writer single-reader circular buffering, which is a data structure enabling multiple asynchronous contexts to interchange data.</p>
<img alt="../_images/vrings.jpg" src="../_images/vrings.jpg" />
<p>This technique is however applicable only in core-to-core configuration, not in core-to-multicore configuration, since in such a case, there would be multiple writers to the “IN” ring buffer. This would require a synchronization element, [such as a semaphore?], which is not desirable.</p>
<p>The above shown picture describes the vring component. Vring is composed of three elementary parts - buffer descriptor pool, the “available” ring buffer (or input ring buffer) and the “used” ring buffer (or free ring buffer). All three elements are physically stored in the shared memory.</p>
<p>Each buffer descriptor contains a 64-bit buffer address, which holds an address to a buffer stored in the shared memory (as seen physically by the “receiver” or host of this vring), its length as a 32-bit variable, 16-bit flags field and 16-bit link to the next buffer descriptor. The link is used to chain unused buffer descriptors and to chain descriptors, which have the F_NEXT bit set in the flags field to the next descriptor in the chain.</p>
<img alt="../_images/vring_descriptor.jpg" src="../_images/vring_descriptor.jpg" />
<p>The input ring buffer contains its own flags field, where only the 0th bit is used - if it is set, the “writer” side should not be notified, when the “reader” side consumes a buffer from the input or “avail” ring buffer. By default the bit is not set, so after the reader consumes a buffer, the writer should be notified by triggering an interrupt. The next field of the input ring buffer is the index of the head, which is updated by the writer, after a buffer index containing a new message is written in the ring[x] field.</p>
<img alt="../_images/vring_descriptor_flags.jpg" src="../_images/vring_descriptor_flags.jpg" />
<p>The last part of the vring is the “used” ring buffer. It contains also a flags field and only the 0th bit is used - if set, the writer side will not be notified when the reader updates the head index of this free ring buffer. The following picture shows the ring buffer structure. The used ring buffer differs from the avail ring buffer. For each entry, the length of the buffer is stored as well.</p>
<img alt="../_images/vrings_used_buffers.jpg" src="../_images/vrings_used_buffers.jpg" />
<p>Both “used” and “avail” ring buffers have a flags field. Its purpose is mainly to tell the writer whether he should interrupt the other core when updating the head of the ring. The same bit is used for this purpose in both “used” and “avail” ring buffers:</p>
<img alt="../_images/vrings_used_buffers_flags.jpg" src="../_images/vrings_used_buffers_flags.jpg" />
</section>
<section id="transport-layer-rpmsg">
<h3>Transport Layer - RPMsg<a class="headerlink" href="#transport-layer-rpmsg" title="Permalink to this heading"></a></h3>
<section id="rpmsg-header-definition">
<h4>RPMsg Header Definition<a class="headerlink" href="#rpmsg-header-definition" title="Permalink to this heading"></a></h4>
<p>Each RPMsg message is contained in a buffer, which is present in the shared memory. This buffer is pointed to by the address field of a buffer descriptor from vring’s buffer descriptor pool. The first 16 bytes of this buffer are used internally by the transport layer (RPMsg layer). The first word (32bits) is used as an address of the sender or source endpoint, next word is the address of the receiver or destination endpoint. There is a reserved field for alignment reasons (RPMsg header is thus 16 bytes aligned). Last two fields of the header are the length of the payload (16bit) and a 16-bit flags field. The reserved field is not used to transmit data between cores and can be used internally in the RPMsg implementation. The user payload follows the RPMsg header.</p>
<img alt="../_images/rpmsg_header.jpg" src="../_images/rpmsg_header.jpg" />
<p>Special consideration should be taken if an alignment greater than 16 bytes is required; however, this is not typical for a shared memory, which should be fast and is therefore often not cached (alignment greater than 8 bytes is not needed at all).</p>
</section>
<section id="flags-field">
<h4>Flags Field<a class="headerlink" href="#flags-field" title="Permalink to this heading"></a></h4>
<p>The flags field of the RPMsg header is currently unused by RPMsg and is reserved. Any propositions for what this field could be used for is welcome. It could be released for application use, but this can be considered as inconsistent - RPMsg header would not be aligned and the reserved field would be therefore useless.</p>
<img alt="../_images/rpmsg_flags.jpg" src="../_images/rpmsg_flags.jpg" />
</section>
<section id="rpmsg-channel">
<h4>RPMsg Channel<a class="headerlink" href="#rpmsg-channel" title="Permalink to this heading"></a></h4>
<p>Every remote core in RPMsg component is represented by RPMsg device that provides a communication channel between master and remote, hence RPMsg devices are also known as channels RPMsg channel is identified by the textual name and local (source) and destination address. The RPMsg framework keeps track of channels using their names.</p>
</section>
<section id="rpmsg-endpoint">
<h4>RPMsg Endpoint<a class="headerlink" href="#rpmsg-endpoint" title="Permalink to this heading"></a></h4>
<p>RPMsg endpoints provide logical connections on top of RPMsg channel. It allows the user to bind multiple rx callbacks on the same channel.</p>
<p>Every RPMsg endpoint has a unique src address and associated call back function. When an application creates an endpoint with the local address, all the further inbound messages with the destination address equal to local address of endpoint are routed to that callback function. Every channel has a default endpoint which enables applications to communicate without even creating new endpoints.</p>
<img alt="../_images/rpmsg_endpoint.jpg" src="../_images/rpmsg_endpoint.jpg" />
</section>
</section>
</section>
<section id="rpmsg-protocol-limitations">
<h2>RPMsg Protocol Limitations<a class="headerlink" href="#rpmsg-protocol-limitations" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>The RPMSG document has the concept of the static channel but it is not implemented in upstream Linux and OpenAMP. Please see <a class="reference external" href="https://www.kernel.org/doc/Documentation/rpmsg.txt">https://www.kernel.org/doc/Documentation/rpmsg.txt</a>. The protocol must define connection sequence when channel is created statically.
No synchronization point is defined by the RPMsg after which both sides can communicate reliably with each other. In the current protocol, at startup, the master sends notification to remote to let it know that it can receive name service announcement. However, master does not consider the fact that if the remote is ready to handle notification at this point in time.</p>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="components.html" class="btn btn-neutral float-left" title="Components and Capabilities" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="rpmsg_comms.html" class="btn btn-neutral float-right" title="RPMsg Communication Flow" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, OpenAMP Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>